/*#include "opencv2/core/core.hpp"
#include "opencv2/flann/miniflann.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/photo/photo.hpp"
#include "opencv2/video/video.hpp"
#include "opencv2/features2d/features2d.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include "opencv2/calib3d/calib3d.hpp"
#include "opencv2/ml/ml.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/contrib/contrib.hpp"
#include "opencv2/core/core_c.h"
#include "opencv2/highgui/highgui_c.h"
#include "opencv2/imgproc/imgproc_c.h"
#include <opencv2/video/background_segm.hpp>
#include <iostream>
#include <windows.h>
#include <strsafe.h>*/
#include "optics.cpp"

#include "json.h"

using namespace std;
using namespace cv;
using namespace Json;
/*
struct ParamsType
{
	char* path;
	int bg_sub;
	int flow_calc;
};

void compute(char* path, char* name)
{
	int s = 1;
	//////////////////////////////////////////////////////////////////////////     
	//image class           
	IplImage* frame = 0;

	//T, T-1 image     
	IplImage* current_frame = 0;
	IplImage* previous_frame = 0;

	//supposedly masks
	Mat current_mask;
	Mat previous_mask;
	Mat united_mask;
	IplImage* united_mask_image;

	//Optical Image     
	IplImage * imgA = 0;
	IplImage * imgB = 0;


	//Video Load     
	CvCapture * capture = cvCreateFileCapture(path); //cvCaptureFromCAM(0); //cvCreateFileCapture("1.avi");     

	//Window     
	//cvNamedWindow(name);
	cvNamedWindow("maskMOG");
	//cvNamedWindow("maskMOG2");
	//cvNamedWindow("modelMOG2");
	cvNamedWindow("OpticalFlowFarneback");

	//////////////////////////////////////////////////////////////////////////     


	//////////////////////////////////////////////////////////////////////////      
	//Optical Flow Variables      
	IplImage * eig_image = 0;
	IplImage * tmp_image = 0;
	//int corner_count = MAX_COUNT;
	CvPoint2D32f* cornersA = new CvPoint2D32f[MAX_COUNT];
	CvPoint2D32f * cornersB = new CvPoint2D32f[MAX_COUNT];

	CvSize img_sz;
	//int win_size = 20;

	IplImage* pyrA = 0;
	IplImage* pyrB = 0;

	//char features_found[MAX_COUNT];
	//float feature_errors[MAX_COUNT];

	Mat previous_gray_frame, current_gray_frame;

	Mat cflow;
	Mat SFlow;
	//////////////////////////////////////////////////////////////////////////     

	/*Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	Mat bgImMOG2;
	BackgroundSubtractorMOG2 mog2_bg_sub(100, 0.0, true); //MOG2 Background subtractor/

	//Mat fgMaskMOG; //fg mask fg mask generated by MOG method
	//Mat bgImMOG;
	BackgroundSubtractor* mog_bg_sub = new BackgroundSubtractorMOG2(); //MOG Background subtractor
	//BackgroundSubtractorMOG mog_bg_sub(100, 2, 0.5, 0.05); //MOG Background subtractor
	//////////////////////////////////////////////////////////////////////////     
	//Variables for time different video     
	//int one_zero = 0;
	//int t_delay = 0;


	/*for (int counter = 0; counter < LEARNING_FRAMES; counter++)
	{
		if (cvGrabFrame(capture) == 0)
			break;
		
		frame = cvRetrieveFrame(capture);

		mog2_bg_sub(Mat(frame), fgMaskMOG2); 
		mog_bg_sub(Mat(frame), fgMaskMOG, 0.5);
	}/
	Ptr<DenseOpticalFlow> dual_tvl1_flow_calc = createOptFlow_DualTVL1();

	double tau = 0.05; // smaller - faster
	double lambda = 0.15;
	double theta = 0.3;
	int nscales = 5;
	int warps = 5;
	double epsilon = 0.05;
	int iterations = 100;
	bool useInitialFlow = false;

	dual_tvl1_flow_calc->set("tau", tau);
	dual_tvl1_flow_calc->set("lambda", lambda);
	dual_tvl1_flow_calc->set("theta", theta);
	dual_tvl1_flow_calc->set("nscales", nscales);
	dual_tvl1_flow_calc->set("warps", warps);
	dual_tvl1_flow_calc->set("epsilon", epsilon);
	dual_tvl1_flow_calc->set("iterations", iterations);
	dual_tvl1_flow_calc->set("useInitialFlow", useInitialFlow);

	prelearn_bg_sub(capture, mog_bg_sub);
	//LK_routine(capture, mog_bg_sub, 0);
	//FB_routine(capture, mog_bg_sub, 0);
	//Routine Start     
	while (1) {


		//capture a frame form cam        
		if (cvGrabFrame(capture) == 0)
			break;

		//Image Create     
		if (previous_frame == 0)
		{
			frame = cvRetrieveFrame(capture);
			
			img_sz = cvSize(frame->width, frame->height);
			current_frame = cvCreateImage(img_sz, frame->depth, frame->nChannels);
			previous_frame = cvCreateImage(img_sz, frame->depth, frame->nChannels);
			mog_bg_sub->operator()(Mat(frame), previous_mask);
			resize(Mat(frame), previous_gray_frame, Size(frame->width / s, frame->height / s));
			cvtColor(previous_gray_frame, previous_gray_frame, CV_BGR2GRAY);
			
			eig_image = cvCreateImage(img_sz, frame->depth, frame->nChannels);
			tmp_image = cvCreateImage(img_sz, frame->depth, frame->nChannels);

			imgA = cvCreateImage(img_sz, IPL_DEPTH_8U, 1);
			imgB = cvCreateImage(img_sz, IPL_DEPTH_8U, 1);
			cout << "inited" << endl;
		}

		//copy to image class     
		memcpy(previous_frame->imageData, current_frame->imageData, sizeof(char)*frame->imageSize);
		frame = cvRetrieveFrame(capture);
		memcpy(current_frame->imageData, frame->imageData, sizeof(char)*frame->imageSize);
		
		
		//mog2_bg_sub(Mat(current_frame), fgMaskMOG2); ///////////////////////////////////////////////SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		
		//mog2_bg_sub.getBackgroundImage(bgImMOG2);

		mog_bg_sub->operator()(Mat(current_frame), current_mask);
		bitwise_or(current_mask, previous_mask, united_mask);

		united_mask_image = cvCreateImage(cvSize(united_mask.cols, united_mask.rows), IPL_DEPTH_8U, 1);
		/*IplImage ipltemp = united_mask;
		cvCopy(&ipltemp, united_mask_image);/
		united_mask_image = cvCloneImage(&(IplImage)united_mask);//

		//RGB to Gray for Optical Flow     
		//cvCvtColor(current_frame, imgA, CV_BGR2GRAY);
		//cvCvtColor(previous_frame, imgB, CV_BGR2GRAY);

		//     
		
		/*cvGoodFeaturesToTrack(imgA, eig_image, tmp_image, cornersA, &corner_count, 0.01, 5.0, united_mask_image, 3, 0, 0.04);
		cvFindCornerSubPix(imgA, cornersA, corner_count, cvSize(win_size, win_size), cvSize(-1, -1), cvTermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, 0.03));


		CvSize pyr_sz = cvSize(imgA->width + 8, imgB->height / 3);
		if (pyrA == 0)
		{
			pyrA = cvCreateImage(pyr_sz, IPL_DEPTH_32F, 1);
			pyrB = cvCreateImage(pyr_sz, IPL_DEPTH_32F, 1);
		}
		//
		cvCalcOpticalFlowPyrLK(imgA, imgB, pyrA, pyrB, cornersA, cornersB, corner_count, cvSize(win_size, win_size), 5, features_found, feature_errors, cvTermCriteria(CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 20, 0.3), 0);
		/
		
		resize(Mat(frame), current_gray_frame, Size(frame->width / s, frame->height / s));
		cvtColor(current_gray_frame, current_gray_frame, CV_BGR2GRAY);
		
		//calcOpticalFlowFarneback(previous_gray_frame, current_gray_frame, flow, 0.5, 3, 15, 3, 5, 1.2, 0);

		//calcOpticalFlowSF(Mat(previous_frame), Mat(current_frame), SFlow, 3, 2, 4);// , 4.1, 25.5, 18, 55.0, 25.5, 0.35, 18, 55.0, 25.5, 10); //SLOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
		cvtColor(previous_gray_frame, cflow, CV_GRAY2BGR);
		dual_tvl1_flow_calc->calc(previous_gray_frame, current_gray_frame, SFlow);
		/*if (!useInitialFlow)
		{
			useInitialFlow = true;
			dual_tvl1_flow_calc->set("useInitialFlow", useInitialFlow);
		}
		//cvCopy(previous_frame, &cflow);///
		drawOptFlowMap(SFlow, cflow, united_mask, 1, CV_RGB(0, 255, 0));
		current_gray_frame.copyTo(previous_gray_frame);

		/////////////////////////////////////////////////////////////////////////        

		/*for (int i = 0; i< corner_count; ++i)
		{

			if (features_found[i] == 0 || feature_errors[i] > MAX_COUNT)
				continue;

			//////////////////////////////////////////////////////////////////////////         
			//Vector Length     
			float fVecLength = sqrt((float)((cornersA[i].x - cornersB[i].x)*(cornersA[i].x - cornersB[i].x) + (cornersA[i].y - cornersB[i].y)*(cornersA[i].y - cornersB[i].y)));
			//Vector Angle     
			float fVecSetha = fabs(atan2((float)(cornersB[i].y - cornersA[i].y), (float)(cornersB[i].x - cornersA[i].x)) * 180.0 / PI);

			cvLine(frame, cvPoint(cornersA[i].x, cornersA[i].y), cvPoint(cornersB[i].x, cornersB[i].y), CV_RGB(0, 255, 0), 2);

			printf("[%d] - Sheta:%lf, Length:%lf\n", i, fVecSetha, fVecLength);
		}/


		//////////////////////////////////////////////////////////////////////////         

		//Mat(image).copyTo(fgMaskMOG, fgMaskMOG); //applies mask
		//Mat(image).copyTo(fgMaskMOG2, fgMaskMOG2);
		//imshow("maskMOG2", fgMaskMOG2);
		//imshow("modelMOG2", bgImMOG2);
		imshow("maskMOG", united_mask);
		imshow("OpticalFlowFarneback", cflow);
		//cvShowImage(name, frame);

		//////////////////////////////////////////////////////////////////////////     


		//break        
		if (cvWaitKey(1) >= 0)
			break;
		previous_mask = current_mask.clone();
	}

	//release capture point        
	cvReleaseCapture(&capture);
	//close the window        
	cvDestroyWindow(name);
	cvDestroyWindow("maskMOG");
	//cvDestroyWindow("maskMOG2");
	//cvDestroyWindow("modelMOG2");
	cvDestroyWindow("OpticalFlowFarneback");
	

	cvReleaseImage(&previous_frame);
	//////////////////////////////////////////////////////////////////////////     
	cvReleaseImage(&imgA);
	cvReleaseImage(&imgB);
	cvReleaseImage(&eig_image);
	cvReleaseImage(&tmp_image);
	delete cornersA;
	delete cornersB;
	cvReleaseImage(&pyrA);
	cvReleaseImage(&pyrB);
	dual_tvl1_flow_calc->collectGarbage();

	//////////////////////////////////////////////////////////////////////////     
}

#include "opencv2/opencv.hpp"
#include <iostream>
#include <vector>
#include <stdio.h>

using namespace cv;
using namespace std;

// Filter type
#define NONE 0  // no filter
#define HARD 1  // hard shrinkage
#define SOFT 2  // soft shrinkage
#define GARROT 3  // garrot filter
//--------------------------------
// signum
//--------------------------------
float sgn(float x)
{
	float res = 0;
	if (x == 0)
	{
		res = 0;
	}
	if (x>0)
	{
		res = 1;
	}
	if (x<0)
	{
		res = -1;
	}
	return res;
}
//--------------------------------
// Soft shrinkage
//--------------------------------
float soft_shrink(float d, float T)
{
	float res;
	if (fabs(d)>T)
	{
		res = sgn(d)*(fabs(d) - T);
	}
	else
	{
		res = 0;
	}

	return res;
}
//--------------------------------
// Hard shrinkage
//--------------------------------
float hard_shrink(float d, float T)
{
	float res;
	if (fabs(d)>T)
	{
		res = d;
	}
	else
	{
		res = 0;
	}

	return res;
}
//--------------------------------
// Garrot shrinkage
//--------------------------------
float Garrot_shrink(float d, float T)
{
	float res;
	if (fabs(d)>T)
	{
		res = d - ((T*T) / d);
	}
	else
	{
		res = 0;
	}

	return res;
}
//--------------------------------
// Wavelet transform
//--------------------------------
static void cvHaarWavelet(Mat &src, Mat &dst, int NIter)
{
	float c, dh, dv, dd;
	assert(src.type() == CV_32FC1);
	assert(dst.type() == CV_32FC1);
	int width = src.cols;
	int height = src.rows;
	for (int k = 0; k<NIter; k++)
	{
		for (int y = 0; y<(height >> (k + 1)); y++)
		{
			for (int x = 0; x<(width >> (k + 1)); x++)
			{
				c = (src.at<float>(2 * y, 2 * x) + src.at<float>(2 * y, 2 * x + 1) + src.at<float>(2 * y + 1, 2 * x) + src.at<float>(2 * y + 1, 2 * x + 1))*0.5;
				dst.at<float>(y, x) = c;

				dh = (src.at<float>(2 * y, 2 * x) + src.at<float>(2 * y + 1, 2 * x) - src.at<float>(2 * y, 2 * x + 1) - src.at<float>(2 * y + 1, 2 * x + 1))*0.5;
				dst.at<float>(y, x + (width >> (k + 1))) = dh;

				dv = (src.at<float>(2 * y, 2 * x) + src.at<float>(2 * y, 2 * x + 1) - src.at<float>(2 * y + 1, 2 * x) - src.at<float>(2 * y + 1, 2 * x + 1))*0.5;
				dst.at<float>(y + (height >> (k + 1)), x) = dv;

				dd = (src.at<float>(2 * y, 2 * x) - src.at<float>(2 * y, 2 * x + 1) - src.at<float>(2 * y + 1, 2 * x) + src.at<float>(2 * y + 1, 2 * x + 1))*0.5;
				dst.at<float>(y + (height >> (k + 1)), x + (width >> (k + 1))) = dd;
			}
		}
		dst.copyTo(src);
	}
}
//--------------------------------
//Inverse wavelet transform
//--------------------------------
static void cvInvHaarWavelet(Mat &src, Mat &dst, int NIter, int SHRINKAGE_TYPE = 0, float SHRINKAGE_T = 50)
{
	float c, dh, dv, dd;
	assert(src.type() == CV_32FC1);
	assert(dst.type() == CV_32FC1);
	int width = src.cols;
	int height = src.rows;
	//--------------------------------
	// NIter - number of iterations 
	//--------------------------------
	for (int k = NIter; k>0; k--)
	{
		for (int y = 0; y<(height >> k); y++)
		{
			for (int x = 0; x<(width >> k); x++)
			{
				c = src.at<float>(y, x);
				dh = src.at<float>(y, x + (width >> k));
				dv = src.at<float>(y + (height >> k), x);
				dd = src.at<float>(y + (height >> k), x + (width >> k));

				// (shrinkage)
				switch (SHRINKAGE_TYPE)
				{
				case HARD:
					dh = hard_shrink(dh, SHRINKAGE_T);
					dv = hard_shrink(dv, SHRINKAGE_T);
					dd = hard_shrink(dd, SHRINKAGE_T);
					break;
				case SOFT:
					dh = soft_shrink(dh, SHRINKAGE_T);
					dv = soft_shrink(dv, SHRINKAGE_T);
					dd = soft_shrink(dd, SHRINKAGE_T);
					break;
				case GARROT:
					dh = Garrot_shrink(dh, SHRINKAGE_T);
					dv = Garrot_shrink(dv, SHRINKAGE_T);
					dd = Garrot_shrink(dd, SHRINKAGE_T);
					break;
				}

				//-------------------
				dst.at<float>(y * 2, x * 2) = 0.5*(c + dh + dv + dd);
				dst.at<float>(y * 2, x * 2 + 1) = 0.5*(c - dh + dv - dd);
				dst.at<float>(y * 2 + 1, x * 2) = 0.5*(c + dh - dv - dd);
				dst.at<float>(y * 2 + 1, x * 2 + 1) = 0.5*(c - dh - dv + dd);
			}
		}
		Mat C = src(Rect(0, 0, width >> (k - 1), height >> (k - 1)));
		Mat D = dst(Rect(0, 0, width >> (k - 1), height >> (k - 1)));
		D.copyTo(C);
	}
}
//--------------------------------
//
//--------------------------------
int process(VideoCapture& capture)
{
	int n = 0;
	const int NIter = 1;
	char filename[200];
	string window_name = "video | q or esc to quit";
	cout << "press space to save a picture. q or esc to quit" << endl;
	namedWindow(window_name, CV_WINDOW_KEEPRATIO); //resizable window;
	Mat frame;
	capture >> frame;

	Mat GrayFrame = Mat(frame.rows, frame.cols, CV_8UC1);
	Mat Src = Mat(frame.rows, frame.cols, CV_32FC1);
	Mat Dst = Mat(frame.rows, frame.cols, CV_32FC1);
	Mat Temp = Mat(frame.rows, frame.cols, CV_32FC1);
	Mat Filtered = Mat(frame.rows, frame.cols, CV_32FC1);
	for (;;)
	{
		Dst = 0;
		capture >> frame;
		if (frame.empty()) continue;
		cvtColor(frame, GrayFrame, CV_BGR2GRAY);
		GrayFrame.convertTo(Src, CV_32FC1);
		cvHaarWavelet(Src, Dst, NIter);

		Dst.copyTo(Temp);

		cvInvHaarWavelet(Temp, Filtered, NIter, HARD, 30);

		imshow(window_name, frame);

		double M = 0, m = 0;
		//----------------------------------------------------
		// Normalization to 0-1 range (for visualization)
		//----------------------------------------------------
		//minMaxLoc(Dst, &m, &M);
		//if ((M - m)>0) { Dst = Dst*(1.0 / (M - m)) - m / (M - m); }
		imshow("Coeff", Dst);

		//minMaxLoc(Filtered, &m, &M);
		//if ((M - m)>0) { Filtered = Filtered*(1.0 / (M - m)) - m / (M - m); }
		imshow("Filtered", Filtered);

		char key = (char)waitKey(5);
		switch (key)
		{
		case 'q':
		case 'Q':
		case 27: //escape key
			return 0;
		case ' ': //Save an image
			sprintf_s(filename, "filename%.3d.jpg", n++);
			imwrite(filename, frame);
			cout << "Saved " << filename << endl;
			break;
		default:
			break;
		}
	}
	return 0;
}
*/
void mamain()
{
	

	//poop();
	//system("pause");
	WIN32_FIND_DATA ffd;
	LARGE_INTEGER filesize;
	TCHAR szDir[MAX_PATH];
	TCHAR file_name[MAX_PATH];
	size_t length_of_arg;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	DWORD dwError = 0;

	StringCchCopy(szDir, MAX_PATH, "D:\\_Old\\librr\\Dyploma\\video_samples\\");
	StringCchCat(szDir, MAX_PATH, TEXT("\\*"));

	hFind = FindFirstFile(szDir, &ffd);

	if (INVALID_HANDLE_VALUE == hFind)
	{
		cout << "boo" << endl;
		return;
	}

	// List all the files in the directory with some info about them.
	cvRedirectError(myErrorHandler);
	do
	{
		if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			cout << ffd.cFileName << endl;
		}
		else
		{
			cout << ffd.cFileName << endl;
			StringCchCopy(file_name, MAX_PATH, "D:\\_Old\\librr\\Dyploma\\video_samples\\");
			StringCchCat(file_name, MAX_PATH, ffd.cFileName);
			//compute(file_name, ffd.cFileName);
			/*routine_handler(file_name, 0, 0, 0);
			routine_handler(file_name, 0, 1, 0);///
			routine_handler(file_name, 1, 0, 0);//*/
			//routine_handler(file_name, 1, 1, 0);//*/
			//routine_handler(file_name, 0, 2, 0);
			routine_handler(file_name, 1, 2, 0);//*/
			//process(VideoCapture(file_name));
			system("pause");
		}
	} while (FindNextFile(hFind, &ffd) != 0);

	FindClose(hFind);

}